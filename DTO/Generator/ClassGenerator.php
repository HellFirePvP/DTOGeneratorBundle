<?php
/**
 * This file is part of the DTO Generator Bundle.
 *
 * (c) HellFirePvP <dev.hellfire@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace HellFirePvP\Bundle\DTOGeneratorBundle\DTO\Generator;

use HellFirePvP\Bundle\DTOGeneratorBundle\DTO\DTObject;
use ReflectionClass;
use UnexpectedValueException;

/**
 * Creates DTO class files with validations and types derived from the class the DTO is for.
 *
 * Takes inspiration from Doctrine's ProxyGenerator.
 *
 * @author HellFirePvP <dev.hellfire@gmail.com>
 */
class ClassGenerator
{
    /**
     * The directory the DTOs are saved into.
     *
     * @var string
     */
    protected string $dtoDirectory;

    /**
     * The Namespace DTOs are organized into.
     *
     * @var string
     */
    protected string $dtoNamespace;

    /**
     * Base Template used to generate DTO classes.
     *
     * @var string
     */
    protected string $dtoClassTemplate = '<?php

namespace <namespace>;

use Symfony\Component\Validator\Constraints as Assert;

/**
 * THIS FILE WAS GENERATED BY THE DTO GENERATOR.
 * DO NOT EDIT THIS FILE.
 */
class <simpleClassName> extends \<fullDTOClassName>
{

<attributes> 

    /**
     * {@inheritDoc}
     */
    public function getObjectClass(): string
    {
        return \<fullClassName>::class;
    }
}
';

    /**
     * @param string $dtoDirectory The directory DTOs are generated into.
     * @param string $dtoNamespace The namespace of generated DTOs
     */
    public function __construct(string $dtoDirectory, string $dtoNamespace)
    {
        $this->dtoDirectory = $dtoDirectory;
        $this->dtoNamespace = $dtoNamespace;
    }

    /**
     * Generates the DTO file for this class and writes the result to the specified file.
     *
     * @param ReflectionClass $class
     * @param string $targetFile
     */
    public function generateDTOFile(ReflectionClass $class, string $targetFile)
    {
        //Inspired by Doctrine's ProxyGenerator
        preg_match_all('(<([a-zA-Z]+)>)', $this->dtoClassTemplate, $placeholderMatches);

        $placeholderMatches = array_combine($placeholderMatches[0], $placeholderMatches[1]);
        $placeholders       = [];

        foreach ($placeholderMatches as $placeholder => $name) {
            $placeholders[$placeholder] = [$this, 'generate' . ucfirst($name)];
        }
        foreach ($placeholders as &$placeholder) {
            if (is_callable($placeholder)) {
                $placeholder = call_user_func($placeholder, $class);
            }
        }

        $this->storeDTOClass(strtr($this->dtoClassTemplate, $placeholders), $targetFile);
    }

    /**
     * Stores the given DTO's class code into the given file.
     *
     * @param string $dtoClass
     * @param string $file
     */
    private function storeDTOClass(string $dtoClass, string $file)
    {
        $parentDirectory = dirname($file);
        if (!is_dir($parentDirectory) && (false === @mkdir($parentDirectory, 0775, true))) {
            throw new UnexpectedValueException(sprintf("DTO file directory not writeable: " . $parentDirectory));
        }

        if (!is_writable($parentDirectory)) {
            throw new UnexpectedValueException(sprintf("DTO file directory not writeable: " . $parentDirectory));
        }

        $tmpFileName = $file . '.' . uniqid('', true);

        file_put_contents($tmpFileName, $dtoClass);
        @chmod($tmpFileName, 0664);
        rename($tmpFileName, $file);
    }

    /**
     * Resolve the actual filename of the DTO class file to generate of the given class.
     *
     * @param ReflectionClass $class
     *
     * @return string
     */
    public function getDTOClassFile(ReflectionClass $class): string
    {
        return rtrim($this->dtoDirectory, DIRECTORY_SEPARATOR) .
            DIRECTORY_SEPARATOR .
            $class->getName() . '.php';
    }

    /**
     * Resolve the full class name of the DTO class file for the given class, usable to load via autoloading.
     *
     * @param ReflectionClass $class
     *
     * @return string
     */
    public function getDTOClassName(ReflectionClass $class): string
    {
        return $this->generateNamespace($class) . '\\' . $this->generateSimpleClassName($class);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// FUNCTIONS ACCESSED DYNAMICALLY TO GENERATE PLACEHOLDER DATA
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Accessed dynamically to generate input for the placeholder "attributes"
     *
     * @param ReflectionClass $class
     * @return string
     */
    private function generateAttributes(ReflectionClass $class): string
    {
        return '';
    }

    /**
     * Accessed dynamically to generate input for the placeholder "simpleClassName"
     *
     * @param ReflectionClass $class
     * @return string
     */
    private function generateSimpleClassName(ReflectionClass $class): string
    {
        return $class->getShortName();
    }

    /**
     * Accessed dynamically to generate input for the placeholder "namespace"
     *
     * @param ReflectionClass $class
     * @return string
     */
    private function generateNamespace(ReflectionClass $class): string
    {
        return $this->dtoNamespace . $class->getNamespaceName();
    }

    /**
     * Accessed dynamically to generate input for the placeholder "fullDTOClassName"
     *
     * @param ReflectionClass $class
     * @return string
     */
    private function generateFullDTOClassName(ReflectionClass $class): string
    {
        return DTObject::class;
    }

    /**
     * Accessed dynamically to generate input for the placeholder "fullClassName"
     *
     * @param ReflectionClass $class
     * @return string
     */
    private function generateFullClassName(ReflectionClass $class): string
    {
        return $class->getName();
    }
}
